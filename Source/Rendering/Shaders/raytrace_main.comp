// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

#define EPSILON 0.0001
#define MAXLEN 1000.0
#define RAYBOUNCES 4
#define REFLECTIONS true
#define REFLECTIONSTRENGTH 0.4
#define REFLECTIONFALLOFF 0.5
//#define DEBUGLINES
#define USE_EMBREE

#include "rt/pbr.glsl"
#include "rt/structs.glsl"
#include "rt/intersect_main.glsl"
#include "rt/ray_gen/main-rg.glsl"
#include "rt/intersect/erp.glsl"

void fresnel(in vec3 I, in vec3 N, in float ior, inout float kr)
{
    float cosi = clamp(-1, 1, dot(I, N));
    float etai = 1, etat = ior;
    if (cosi > 0) { //SWAP
        float temp = etai;
        etai = etat;
        etat = temp;
    }
    // Compute sini using Snell's law
    float sint = etai / etat * sqrt(max(0.f, 1 - cosi * cosi));
    // Total internal reflection
    if (sint >= 1) {
        kr = 1;
    }
    else {
        float cost = sqrt(max(0.f, 1 - sint * sint));
        cosi = abs(cosi);
        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
        kr = (Rs * Rs + Rp * Rp) / 2;
    }
    // As a consequence of the conservation of energy, transmittance is given by:
    // kt = 1 - kr;
}

// Lighting =========================================================

float lightDiffuse(vec3 normal, vec3 lightDir)
{
    return clamp(dot(normal, lightDir), 0.1, 1.0);
}

float lightSpecular(vec3 normal, vec3 lightDir, float specularFactor)
{
    vec3 viewVec = normalize(ubo.rotM[3].xyz);
    vec3 halfVec = normalize(lightDir + viewVec);
    return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}

finalmaterial renderScene(inout Ray ray, inout vec3 norm, in float ri)
{
    finalmaterial fMat;
    fMat.color = vec3(0.0);
    fMat.reflection = 0.0;
    fMat.refraction = 1.0;
    fMat.transparency = 0.0f;

    ray.t = MAXLEN;
    ray.t2 = MAXLEN;
    vec2 uv = vec2(0.0);
    // Get intersected primitive ID


    #ifdef USE_EMBREE
        iSectID intersectID[2] = intersectEmbreeBvh(ray, norm, uv);
    #else
        iSectID intersectID[2] = intersectMBVH(ray, norm, uv);
    #endif

    //if it doesn't interset anything, return the material
    if (intersectID[0].faceID == -1) {
        //		fMat.color = vec3(0.99f, 0.99f, 1.0f);
        fMat.color = vec3(0.f, 0.f, 0.f);

        /*ivec2 dim = imageSize(resultImage);
                                        		vec2 uv = vec2(gl_GlobalInvocationID.x, dim.y - gl_GlobalInvocationID.y + 180) / dim;

                                        		fMat.color = texture(bindless_textures[nonuniformEXT(3)], uv).xyz;*/
        return fMat;
    }

    #ifdef DEBUGLINES
    //do an intersection test with the bvh node
    if (bvhBoundsIntersect(ray, 1 / ray.d, bvhNodes[intersectID[0].nodeID])) {
        fMat.color = vec3(0, 1, 0);
        return fMat;
    }
    #endif

    vec3 pos = ray.o + ray.t * ray.d;
    vec3 normal;
    vec3 txtr;
    vec4 txtr2;
    /////////////////SWAP HERE FOR DEBUG///////////////////////
    // For debug lines, you want the id of the prim u isect //
    //////////////////////////////////////////////////////////
    Material mat = materials[primitives[intersectID[0].faceID].matID];
    //Material mat = materials[primitives[intersectID[0].pId].matID];

    switch (intersectID[0].primType) {
        case TYPE_PLANE:
        {
            break;
        }
        case TYPE_DISK:
        {
            normal = vec3(0, 1, 0);
            break;
        }
        case TYPE_SPHERE:
        {
            normal = sphereNormal(pos, primitives[intersectID[0].faceID]);
            break;
        }
        case TYPE_BOX:
        {
            normal = norm;
            if (mat.textureID > 0)
                txtr = boxTexture(pos, normal, primitives[intersectID[0].faceID], bindless_textures[nonuniformEXT(mat.textureID)]);
            break;
        }
        case TYPE_QUAD:
        {
            normal = norm;
            if (mat.textureID > 0) {
                txtr2 = texture(bindless_textures[nonuniformEXT(mat.textureID)], uv);
                if(txtr2.a < 0.1){
                    intersectID[0] = intersectID[1];
                    ray.t = ray.t2;
                }
                else
                {
                    txtr = txtr2.rgb;
                }
            }
        }
        case TYPE_CYLINDER:
        {
            normal = norm;
            break;
        }
        case TYPE_MESH:
        {
            //normal = triNormalUV(primitives[intersectID[0].primID], faces[intersectID[0].faceID], norm.x, norm.y);
            normal = quadNormal(primitives[intersectID[0].primID], faces[intersectID[0].faceID], norm.x, norm.y);
            mat = materials[primitives[intersectID[0].primID].matID];
            txtr = texture(bindless_textures[nonuniformEXT(mat.textureID)], norm.xy).xyz;
            //if(mat.textureID > 0)
            //	fMat.color = vec3(texture(bindless_textures[nonuniformEXT(mat.textureID)], vec2(norm).xy)).xyz;
            break;
        }
    }

    float shadow = 0;
    float power = 0;

    vec3 View = normalize(ubo.rotM[3].xyz - pos);
    for (int i = 0; i < lights.length(); ++i) {
        vec3 F0 = vec3(0.04);
        F0 = mix(F0, mat.diffuse, mat.reflective);
        vec3 distance = lights[i].pos - pos;
        float ld = length(distance);
        power = lights[i].intensity / (ld * ld);
        vec3 lightDirection = normalize(distance);
        if (power > 0.1f) {
            if (mat.textureID > 0)
                fMat.color += specularContribution(lightDirection, View, normal, F0, txtr + mat.diffuse, mat.reflective, mat.roughness) * power;
            else
                fMat.color += specularContribution(lightDirection, View, normal, F0, mat.diffuse, mat.reflective, mat.roughness) * power;

            if (shadow < 0.9f) {
                Ray shadowRay = Ray(pos, length(distance), lightDirection, 0);
                #ifdef USE_EMBREE
                    shadow += calcShadowEmbreeBVH(shadowRay);
                #else
                    shadow += calcShadowBVH(shadowRay);
                #endif

            }
            //	if(shadow >= 0.9f){
            //		shadow = 1;
            //	}
        }
    }
    //if (power > 8) power = 8;

    //if (shadow > 1) shadow = 1;
    shadow = shadow * float(shadow < 0.9f) + float(shadow >= .9f);

    fMat.color *= shadow;
    fMat.reflection = mat.reflective;
    fMat.refraction = mat.refractiveIndex;
    fMat.transparency = mat.transparency;



    ray.d = reflect(ray.d, normal);

    ray.o = pos;

    return fMat;
}

// Casts ray into scene
HitInfo[MAX_INTERSECTIONS] trace_ray_any(Ray ray)
{
    ray.t = MAXLEN;
    ray.t2 = MAXLEN;
    vec2 uv = vec2(0.0);
    vec3 norm = vec3(0.0);

    //iSectID intersectID[2] = intersectEmbreeBvh(ray, norm, uv);

    HitInfo[MAX_INTERSECTIONS] id;
    return id;
}

HitInfo trace_ray_closest(inout Ray ray)
{
    return intersect_closest(ray);
}

void main()
{
    vec3 combinedColor = vec3(0);
    vec4 txt = vec4(0);
    Ray[SAMPLES] rays = main_rg(txt);

    for (int samp = 0; samp < SAMPLES; ++samp)
    {
        vec3 normal = vec3(0.f, 0.f, 0.f);
        // Basic color path
        float refractiveIndex = 1.0; //assuming its air
        finalmaterial finalColor = renderScene(rays[samp], normal, refractiveIndex);

        // Reflection
        if (REFLECTIONS)
        {
            float reflectionStrength = finalColor.reflection; //REFLECTIONSTRENGTH;
            float refractionStrength = 1 - reflectionStrength;
            for (float i = 0; i < RAYBOUNCES; i++)
            {
                float fallmul = (i + 1) * (i + 1);
                if (reflectionStrength > 0.05F) {
                    finalmaterial reflectionColor = renderScene(rays[samp], normal, finalColor.refraction);
                    finalColor.color = (1.0 - reflectionStrength) * finalColor.color + reflectionStrength * mix(reflectionColor.color, finalColor.color, 1.0 - reflectionStrength);
                    reflectionStrength *= (REFLECTIONFALLOFF / fallmul) * reflectionColor.reflection;
                }
            }
        }
        combinedColor += finalColor.color / SAMPLES;
        imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(combinedColor * (1 - txt.a), 0.0));

    }
    //imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), texture(bindless_textures[nonuniformEXT(1)], uv));
}
