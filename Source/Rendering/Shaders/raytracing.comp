// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

#define EPSILON 0.0001
#define MAXLEN 1000.0
#define SHADOW 0.2
#define RAYBOUNCES 4
#define REFLECTIONS true 
#define REFLECTIONSTRENGTH 0.4
#define REFLECTIONFALLOFF 0.5
#define TRIINTERSECT true	


#include "rt/structs.glsl"
#include "rt/intersect_main.glsl"


void reflectRay(inout vec3 rayD, in vec3 mormal)
{
	
	rayD = reflect(rayD, mormal);
	//rayD = rayD + 2.0 * -dot(mormal, rayD) * mormal;
}

void fresnel(in vec3 I, in vec3 N, in float ior, inout float kr) 
{ 
    float cosi = clamp(-1, 1, dot(I, N)); 
    float etai = 1, etat = ior; 
    if (cosi > 0) { //SWAP
		float temp = etai;
		etai = etat;
		etat = temp;
	} 
    // Compute sini using Snell's law
    float sint = etai / etat * sqrt(max(0.f, 1 - cosi * cosi)); 
    // Total internal reflection
    if (sint >= 1) { 
        kr = 1; 
    } 
    else { 
        float cost = sqrt(max(0.f, 1 - sint * sint)); 
        cosi = abs(cosi); 
        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); 
        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); 
        kr = (Rs * Rs + Rp * Rp) / 2; 
    } 
    // As a consequence of the conservation of energy, transmittance is given by:
    // kt = 1 - kr;
} 

// Lighting =========================================================

float lightDiffuse(vec3 normal, vec3 lightDir) 
{
	return clamp(dot(normal, lightDir), 0.1, 1.0);
}

float lightSpecular(vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(ubo.pos);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}
	


finalmaterial renderScene(inout vec3 rayO, inout vec3 rayD, inout vec3 norm, in float ri)
{
	finalmaterial fMat;
	fMat.color = vec3(0.0);
	fMat.reflection = 0.0;
	fMat.refraction = 1.0;
	fMat.transparency = 0.0f;

	float t = MAXLEN;
	//vec3 norm;

	// Get intersected primitive ID
	sectID primitiveID = intersect(rayO, rayD, t, norm);
	
	if (primitiveID.id == -1)
	{
		return fMat;
	}
	
	vec3 pos = rayO + t * rayD;
	//vec3 lightVec = normalize(lights[0].pos - pos);				
	vec3 normal;

	switch(primitiveID.type){
		case TYPE_PLANE:{
			break;
		}
		case TYPE_DISK:{
			normal = vec3(0,1,0);
			break;
		}
		case TYPE_SPHERE:{
			normal = sphereNormal(pos, primitives[primitiveID.id]);
			break;
		}
		case TYPE_BOX:{
			normal = norm;
			break;
		}
		case TYPE_MESH:{
			normal = norm;//triNormal(indices[primitiveID.cId]);
			break;
		}
	}

	float diffuse = 0;
	float specular = 0;
	float power = 0;
	float shadow = 0;
	for(int i = 0; i < lights.length(); ++i){
		vec3 distance = lights[i].pos - pos;
		vec3 lightVec = normalize(distance);
		float ld = length(distance);
		diffuse += lightDiffuse(normal, lightVec);
		specular += lightSpecular(normal, lightVec, 32.0f);
		power += lights[i].intensity / (ld * ld);
		if (power > 0.1)
			shadow += calcShadow(pos, lightVec, primitiveID, ld);
	}
	if (power > 1) power = 1;
	if (shadow > 1) shadow = 1;

	Material mat = materials[primitives[primitiveID.id].matID];
	fMat.color = diffuse * mat.diffuse + specular;
	fMat.color *= power * shadow;
	fMat.reflection = mat.reflective;
	fMat.refraction = mat.refractiveIndex;
	fMat.transparency = mat.transparency;
		
	// Reflect ray for next render pass
	if(fMat.transparency > EPSILON){
		fMat.refraction /= ri;
		fresnel(rayD, normal, fMat.refraction, fMat.reflection);
	}
	reflectRay(rayD, normal);

	rayO = pos;	
	
	return fMat;
}

void main()
{
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
	vec2 ps = (-1.0 + 2.0 * uv) * vec2(ubo.aspectRatio, 1.0);
	vec3 rayD = normalize(vec3(ps.x, -1.0, ps.y));
	//vec3 rayD = normalize(vec3(ps.x, ps.y, -1));
	vec3 rayO = ubo.pos;
	vec3 normal = vec3(0.f, 0.f, 0.f);

		
	// Basic color path
	float refractiveIndex = 1.0; //assuming its air
	finalmaterial finalColor = renderScene(rayO, rayD, normal, refractiveIndex);
	
	// Reflection
	if (REFLECTIONS)
	{
		float reflectionStrength = finalColor.reflection;//REFLECTIONSTRENGTH;
		float refractionStrength = 1 - reflectionStrength;
		for (float i = 0; i < RAYBOUNCES; i++)
		{
			float fallmul = (i+1) * (i+1);
			if(reflectionStrength > 0.05F){
				finalmaterial reflectionColor = renderScene(rayO, rayD, normal, finalColor.refraction);
				finalColor.color = (1.0 - reflectionStrength) * finalColor.color + reflectionStrength * mix(reflectionColor.color, finalColor.color, 1.0 - reflectionStrength);			
				reflectionStrength *= (REFLECTIONFALLOFF / fallmul);
			}
		}
	}
			
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor.color, 0.0));
}